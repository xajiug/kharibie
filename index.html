<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>RTS Step 1 — Builder Move (Portrait)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b1220; }
    #game { width:100%; height:100%; }
    .hud {
      position:fixed; top:8px; left:8px; right:8px;
      display:flex; gap:8px; align-items:center; color:#e8eefc; font-family:system-ui;
      pointer-events:none; font-size:14px;
      text-shadow:0 1px 2px rgba(0,0,0,.5);
      html, body { overscroll-behavior: none; }
canvas { touch-action: none; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game"></div>
  <div class="hud">Шаг 1 · Тап по юниту — выделить · Тап по карте — идти · 2 пальца — пан/пинч</div>
  <script>
    const MAP_SIZE = 2000;
    const START_ZOOM = 0.9;
    const Design = {
      colors: { ally: 0x29b6f6, enemy: 0xef5350, grid: 0x17305a, select: 0xffffff },
      unit: { size: 16, speed: 180, hp: 100 },
    };
    const config = {
      type: Phaser.AUTO,
      parent: 'game',
      backgroundColor: '#0b1220',
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: window.innerWidth,
        height: window.innerHeight,
      },
      render: { pixelArt: true, antialias: false },
      scene: { preload, create, update }
    };
    const game = new Phaser.Game(config);
    let gfx, cam, gridStep = 100;
    let builder = null;
    let isSelected = false;
    let latestTap = 0;
    let pinchDistance = null;

    function preload() {}

    function create() {
      this.input.addPointer(2);
      cam = this.cameras.main;
      cam.setBounds(0, 0, MAP_SIZE, MAP_SIZE);
      cam.setZoom(START_ZOOM);
      cam.centerOn(MAP_SIZE / 2, MAP_SIZE / 2);

      gfx = this.add.graphics();

      builder = this.add.rectangle(MAP_SIZE/2, MAP_SIZE/2, Design.unit.size, Design.unit.size, Design.colors.ally);
      builder.setDepth(10);
      builder.target = null;
      builder.speed = Design.unit.speed;

      builder.outline = this.add.rectangle(builder.x, builder.y, Design.unit.size+6, Design.unit.size+6);
      builder.outline.isStroked = true;
      builder.outline.strokeColor = 0xffffff;
      builder.outline.strokeAlpha = 0.0;
      builder.outline.lineWidth = 2;
      builder.outline.setDepth(11);

      this.input.on('pointerdown', (pointer) => {
        const now = performance.now();
        if (now - latestTap < 30) return;
        latestTap = now;
        if (this.input.pointersTotal >= 2) return;
        const world = screenToWorld(pointer.x, pointer.y, cam);
        if (Phaser.Geom.Rectangle.Contains(
              new Phaser.Geom.Rectangle(builder.x-Design.unit.size/2, builder.y-Design.unit.size/2, Design.unit.size, Design.unit.size),
              world.x, world.y
            )) {
          isSelected = !isSelected;
          builder.outline.strokeAlpha = isSelected ? 1.0 : 0.0;
          return;
        }
        if (isSelected) builder.target = { x: world.x, y: world.y };
      });

      this.input.on('pointermove', (pointer) => {
        if (!pointer.isDown) return;
        const isRightButton = pointer.event && pointer.event.buttons === 2;
        if (this.input.pointersTotal >= 2 || isRightButton) {
          cam.scrollX -= pointer.velocity.x / 2;
          cam.scrollY -= pointer.velocity.y / 2;
        }
      });

      this.input.on('pointermove', () => {
        const p1 = this.input.pointer1;
        const p2 = this.input.pointer2;
        if (p1 && p2 && p1.isDown && p2.isDown) {
          const dist = Phaser.Math.Distance.Between(p1.x, p1.y, p2.x, p2.y);
          if (pinchDistance == null) pinchDistance = dist;
          const delta = dist - pinchDistance;
          pinchDistance = dist;
          const newZoom = Phaser.Math.Clamp(cam.zoom + delta * 0.0015, 0.4, 2.0);
          cam.setZoom(newZoom);
        } else {
          pinchDistance = null;
        }
      });

      this.input.keyboard?.on('keydown', (e) => {
        const s = 20 / cam.zoom;
        if (e.key === 'ArrowUp') cam.scrollY -= s;
        if (e.key === 'ArrowDown') cam.scrollY += s;
        if (e.key === 'ArrowLeft') cam.scrollX -= s;
        if (e.key === 'ArrowRight') cam.scrollX += s;
      });
    }

    function update(time, delta) {
      drawGrid();
      if (builder.target) {
        const dx = builder.target.x - builder.x;
        const dy = builder.target.y - builder.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 1) {
          const nx = dx / dist, ny = dy / dist;
          const step = (builder.speed * (delta/1000));
          builder.x += nx * step;
          builder.y += ny * step;
          builder.outline.x = builder.x;
          builder.outline.y = builder.y;
        } else {
          builder.target = null;
        }
      } else {
        builder.outline.x = builder.x;
        builder.outline.y = builder.y;
      }
    }

    function drawGrid() {
      gfx.clear();
      gfx.lineStyle(1, 0x17305a, 1);
      for (let x = 0; x <= MAP_SIZE; x += 100) {
        gfx.strokeLineShape(new Phaser.Geom.Line(x, 0, x, MAP_SIZE));
      }
      for (let y = 0; y <= MAP_SIZE; y += 100) {
        gfx.strokeLineShape(new Phaser.Geom.Line(0, y, MAP_SIZE, y));
      }
    }
    function screenToWorld(sx, sy, camera) {
      return { x: sx / camera.zoom + camera.scrollX, y: sy / camera.zoom + camera.scrollY };
    }
    window.addEventListener('resize', () => {
      game.scale.resize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
